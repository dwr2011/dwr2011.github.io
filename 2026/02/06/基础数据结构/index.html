
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>基础数据结构 - Vernal_blossom&#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="基础数据结构栈栈是一种数据结构，支持：

push ：往栈里面压入一个元素
pop ：把栈中最后被压入的元素（栈顶）丢掉。

并且栈中时时刻刻都只能查询栈顶的值。
栈在计算机中的应用极其广泛。本质上,"> 
    <meta name="author" content="vernal_blossom"> 
    <link rel="alternative" href="atom.xml" title="Vernal_blossom&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="基础数据结构 - Vernal_blossom&#39;s blog"/>
    <meta name="twitter:description" content="基础数据结构栈栈是一种数据结构，支持：

push ：往栈里面压入一个元素
pop ：把栈中最后被压入的元素（栈顶）丢掉。

并且栈中时时刻刻都只能查询栈顶的值。
栈在计算机中的应用极其广泛。本质上,"/>
    
    
    
    
    <meta property="og:site_name" content="Vernal_blossom&#39;s blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="基础数据结构 - Vernal_blossom&#39;s blog"/>
    <meta property="og:description" content="基础数据结构栈栈是一种数据结构，支持：

push ：往栈里面压入一个元素
pop ：把栈中最后被压入的元素（栈顶）丢掉。

并且栈中时时刻刻都只能查询栈顶的值。
栈在计算机中的应用极其广泛。本质上,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 8.1.1"></head>

<body class="loading">
    <span id="config-title" style="display:none">Vernal_blossom&#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://dwr2011.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">基础数据结构</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">基础数据结构</h1>
        <div class="stuff">
            <span>二月 06, 2026</span>
            

        </div>
        <div class="content markdown">
            <h1 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种数据结构，支持：</p>
<ul>
<li><code>push</code> ：往栈里面压入一个元素</li>
<li><code>pop</code> ：把栈中最后被压入的元素（栈顶）丢掉。</li>
</ul>
<p>并且栈中时时刻刻都只能查询栈顶的值。</p>
<p>栈在计算机中的应用极其广泛。本质上来说，递归程序都是通过压栈的方式实现的。</p>
<p>STL 中给出了一个栈的实现 <code>stack&lt;T&gt; a</code> ，在头文件 <code>#include&lt;stack&gt;</code> 中，支持常见函数 <code>push,pop,top,size</code> 等。</p>
<p>栈在算法竞赛中也有不少的应用，最常见的应用就是单调栈。</p>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>单调栈存储的是所有<strong>后缀最值被取到</strong>的位置。</p>
<p>具体来说，例如存储后缀最大值的单调栈，加入一个新的元素时，一直弹出栈顶知道当前位置小于栈顶元素，然后把当前元素加入栈中。</p>
<p>显然，单调栈总是一个单调的序列，例如存储最大值的单调栈总是单调递减的，前面存储的都是比当前元素大的元素。并且每次加入一个元素后，它总会被压入栈的末尾，毕竟它本身一定能作为后缀最大值。</p>
<p>每次单调栈只会压入一个元素，因此对整个序列扫完一遍后，总复杂度是 $O(n)$ 的。</p>
<h3 id="例题-1-Look-Up"><a href="#例题-1-Look-Up" class="headerlink" title="例题 #1 Look Up"></a>例题 #1 Look Up</h3><p>给定一个序列，对于每个位置 $i$ 求出它左边的第一个比 $A_i$ 大的数的下标。</p>
<p>求出维护后缀最大值的单调栈，在加入当前这个数之前的栈顶就是所求的值。</p>
<h3 id="例题-2-求数列所有后缀最大值的位置"><a href="#例题-2-求数列所有后缀最大值的位置" class="headerlink" title="例题 #2 求数列所有后缀最大值的位置"></a>例题 #2 求数列所有后缀最大值的位置</h3><p>后缀最大值的位置其实就是单调栈的本质。</p>
<p>维护出单调栈后 ，要求的其实就是单调栈中所有数的异或和。</p>
<p>往单调栈压入数和弹出数都给这个值异或一次被操作的数即可。</p>
<h3 id="例题-3-Decryption"><a href="#例题-3-Decryption" class="headerlink" title="例题 #3 Decryption"></a>例题 #3 Decryption</h3><p>用单调栈的方法求出每个位置左边的第一个比当前位置大和小的位置 $mx[i],mn[i]$ 。</p>
<p>然后从 $n$ 开始往前跳。很显然，每一段能选的左段点是 $mx[i]$ 后面的第一个在最小值单调栈上的编号。</p>
<p>那么确定 $R &#x3D; mx[i],j &#x3D; i$ 时可以一直跳 $j \leftarrow mn[j]$ ，直到 $mn[j] &lt; R$ 为止。</p>
<p>得到的位置就是能够选的最靠左的左段点。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>一般队列：允许取出队首队尾、弹出队首、加入队尾的数据结构。</p>
<p>双端队列：允许在队首队尾执行修改的队列。</p>
<p>队列同样有 STL 可以使用。<code>#include&lt;queue&gt;</code> 后可以使用 <code>queue&lt;T&gt;</code> 表达一个存储 <code>T</code> 类型的队列。</p>
<p>怎么用栈实现双端队列？</p>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列和单调栈没有什么本质区别，就是额外增加了删除最早的值的操作。</p>
<p>有时候我们想要求出的值不仅需要满足比当前位置小，还需要满足位置上的一些关系，就需要使用单调队列。</p>
<h3 id="例题-4-求m区间内的最小值"><a href="#例题-4-求m区间内的最小值" class="headerlink" title="例题 #4 求m区间内的最小值"></a>例题 #4 求m区间内的最小值</h3><p>可以类似维护出后缀最小值的队列。但是问题是怎么限制队列中的元素都在当前位置的前 $m$ 个位置之中。</p>
<p>每次求最小值的时候就弹出 $i - m$ 之前的所有值即可。</p>
<p>单调队列的队首总是这 $m$ 个位置的最小值。这就是经典的滑动窗口问题。</p>
<h3 id="例题-5-区间极差"><a href="#例题-5-区间极差" class="headerlink" title="例题 #5 区间极差"></a>例题 #5 区间极差</h3><p>二分需要的区间长度，然后就变成了判定是否存在一段这么长的区间，满足里面的 $y$ 的极差大于 $d$ 。</p>
<p>这其实就是一个滑动窗口问题，分别维护最小值和最大值的单调队列即可。</p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列是通过堆实现的。堆是一棵完全二叉树，满足任何一个点的值都大于等于其两个儿子的值。不难发现堆的根一定是所有数中最大的。</p>
<p>因此 STL 把堆抽象成了一种类似于队列的数据结构。它同样能往里面压入东西，但是取队首时不再是取最早压入的东西了，而是取出权值最大的东西（大根堆）。</p>
<p>可以使用 <code>#include&lt;queue&gt;</code> 并且通过 <code>priority_queue&lt;T&gt;</code> 来定义一个 <code>T</code> 类型的优先队列。</p>
<p>如果想要用 <code>T</code> 类型来定义优先队列，必须保证 <code>T</code> 具有 <code>&lt;</code> 符号的重载。毕竟如果一个类型不存在大小关系，那就不存在“最大的值”的概念了。</p>
<p>如果想要让自己的结构题放到优先队列里，应该这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="function">node <span class="title">operator</span> <span class="params">( node a )</span> &lt; <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &lt; a.val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意，<code>priority_queue</code> 总是默认大根堆的，队首总是取出的最大值。</p>
<p>如果想要小根堆，基本类型可以取负，自定义类型可以在函数里给大小于变下号。</p>
<p>可删除的堆怎么做？</p>
<h3 id="例题-6-合并果子"><a href="#例题-6-合并果子" class="headerlink" title="例题 #6 合并果子"></a>例题 #6 合并果子</h3><p>经典的贪心问题，总是把当前最小的两堆果子合并即可。</p>
<p>因此可以开一个堆来维护当前最小的果子是什么。如果堆里面的堆数大于等于 $2$ 就取出最小的两堆，合并起来再放回去。</p>
<h3 id="例题-7-队列"><a href="#例题-7-队列" class="headerlink" title="例题 #7 队列"></a>例题 #7 队列</h3><p>首先，假设我们不考虑所有 $4$ 操作，那么所有操作和队列操作是很像的。</p>
<p>每次往后加入 $1,2,\ldots,x$ 时，没必要真的全加进去，加入 $x$ 即可。对于队首 $x$ ，我们用一个变量表示它前面的 $1,2,\ldots,k$ 已经被弹出了，只剩 $k+1,k+2,\ldots,x$ 。</p>
<p>每次查询的时候，我们可以前缀和求出每个 $x$ 的真实下标，通过二分的方法找出第 $z$ 个元素在哪里。</p>
<p>查询最大值时，可以发现查询的值总是 $x$ ，不可能是 $1,2,\ldots,x-1$ 中的值。因此每次删除和插入新的 $x$ 的时候直接插入或删除即可。</p>
<p>如何在堆做删除已经介绍过了。</p>
<h3 id="例题-8-黑匣子"><a href="#例题-8-黑匣子" class="headerlink" title="例题 #8 黑匣子"></a>例题 #8 黑匣子</h3><p>可以用两个优先队列，分别维护 $i$ 之前的所有元素和 $i$ 之后的所有元素。</p>
<p>当插入一个数时，看看它是否大于 $i$ 之前的最大数，如果大于就插入到后面，否则插入到前面，并且把前面的最大数插入到后面即可。</p>
<h2 id="STL-容器"><a href="#STL-容器" class="headerlink" title="STL 容器"></a>STL 容器</h2><h3 id="一般-STL-容器-vector-和-迭代器"><a href="#一般-STL-容器-vector-和-迭代器" class="headerlink" title="一般 STL 容器 vector 和 迭代器"></a>一般 STL 容器 <code>vector</code> 和 迭代器</h3><p><code>vector</code> 是一个可变长的数组容器。</p>
<p>可以通过下标访问数组中的元素，支持以下基础操作</p>
<ul>
<li><code>push_back( x )</code> 往后加入 $x$ 元素。</li>
<li><code>pop_back()</code> 弹出末尾。</li>
<li><code>resize()</code> 调整大小，增长则补 $0$ 。</li>
<li><code>size()</code> 返回大小</li>
<li><code>back()</code> 访问最后一个元素</li>
</ul>
<p>可以使用 <code>[]</code> 来访问某个位置的元素。</p>
<p>迭代器：<code>vector&lt;T&gt;::iterator</code> ，可以认为是一个指向某个位置的指针。</p>
<p><code>vector</code> 的基础迭代器：<code>begin()</code> 和 <code>end()</code> 分别可以返回指向开头和指向结尾的下一个位置的迭代器。</p>
<p>对于迭代器 <code>it</code> ，可以通过 <code>*it</code> 访问迭代器指向位置的值。</p>
<p>迭代器支持加减法，可以通过 <code>it = it + 3</code> 让迭代器指向的位置往后移动三个元素。支持迭代器做差，可以通过 <code>itr - itl</code> 得到两个迭代器指向元素的下标差。</p>
<p>迭代器的遍历方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">3</span> , <span class="number">2</span> , <span class="number">5</span> , <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>() ; it != vec.<span class="built_in">end</span>() ; ++ it ) &#123;</span><br><span class="line">  cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过迭代器访问第三个元素：<code>*(vec.begin() + 2)</code> 。</p>
<p>学会迭代器是什么后，<code>vector</code> 提供了一个更方便的功能：</p>
<ul>
<li><code>erase( it )</code> 删除迭代器处的元素，把后面的元素补上来。</li>
<li>也可以通过 <code>erase( itl , itr )</code> 把一段的元素删除掉</li>
<li><code>insert( it , val )</code> 把 <code>val</code> 插入到 <code>it</code> 这个迭代器的前面。</li>
<li><code>insert( it , itl , itr )</code> 把 <code>[itl,itr)</code> 插入到 <code>it</code> 的前面</li>
</ul>
<p>两个 <code>vector</code> 可以比较大小，比较的方法是字典序。</p>
<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set &#x2F; multiset"></a>set &#x2F; multiset</h3><p>一种有序容器，可以由 <code>set&lt;T&gt; S</code> 定义，其中不能有重复元素。</p>
<p>可以用 <code>multiset</code> 定义一个可以有重复元素的对应容器。</p>
<p>支持以下功能：</p>
<ul>
<li><code>insert</code> 加入一个元素</li>
<li><code>erase</code> 删除一个元素或删除所有某个元素，可以删除迭代器也可以删除一段迭代器</li>
<li><code>begin</code> 返回开头元素的迭代器</li>
<li><code>end</code> 返回结尾元素的下一个位置的迭代器</li>
<li><code>rbegin,rend</code> 反过来的开头迭代器和结尾迭代器</li>
<li><code>lower_bound</code> 返回大于等于某个元素的第一个位置的迭代器</li>
<li><code>upper_bound</code> 返回大于某个元素的第一个位置的迭代器</li>
<li><code>find</code> 返回某个元素的迭代器</li>
<li><code>count</code> 返回某个元素的个数</li>
<li><code>size</code> 返回大小</li>
<li><code>clear</code> 清空</li>
</ul>
<p>两个 <code>set</code> 之间可以执行等于、比较等操作。</p>
<p><code>set</code> 无法下标访问，只能这么遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; S = &#123; <span class="number">3</span> , <span class="number">2</span> , <span class="number">5</span> , <span class="number">4</span> , <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> it = S.<span class="built_in">begin</span>() ; it != S.<span class="built_in">end</span>() ; ++ it ) &#123;</span><br><span class="line">  <span class="type">int</span> x = *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set</code> 的功能是通过红黑树实现的，并且 <code>set&lt;T&gt;</code> 中的 <code>T</code> 必须可以比较大小，也就是说必须重载了 <code>&lt;</code> 符。这里的小于符号必须是一个偏序关系，千万别在里面写 <code>&lt;=</code> 。</p>
<p><code>set</code> 的迭代器是不支持随机访问的，因此只能 <code>it ++</code> 不能 <code>it += 3</code> ，更不能 <code>itr - itl</code> 。</p>
<p>同时，可以通过 <code>unordered_set/multiset</code> 来定义一个无序的 <code>set</code> ，其大部分功能和这个 <code>set</code> 相同，更快，但是不支持 <code>lower_bound</code> 等和顺序有关的功能。</p>
<h3 id="例题-9-地道战"><a href="#例题-9-地道战" class="headerlink" title="例题 #9 地道战"></a>例题 #9 地道战</h3><p>可以用 <code>set</code> 存储所有被炸毁的房子的编号。</p>
<p>每次查询 $x$ 时可以找到大于 $x$ 的第一个编号，通过 <code>lower_bound</code> ，并且 <code>--it</code> 即可找到小于 $x$ 的最大编号，然后把两个编号做差即可。</p>
<h3 id="例题-10-营业额统计"><a href="#例题-10-营业额统计" class="headerlink" title="例题 #10 营业额统计"></a>例题 #10 营业额统计</h3><p>和上一题一样，找到大于 $x$ 的第一编号，然后再给迭代器减 $1$ 找到小于 $x$ 的最大编号，然后和当前值做差取 <code>min</code> 即可。</p>
<h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h3><p>和 <code>set</code> 非常类似的容器。</p>
<p>用 <code>map&lt;Key,Val&gt;</code> 定义一个 <code>Key -&gt; Val</code> 的映射。你可以看作一个下标类型任意的数组。</p>
<p>例如定义 <code>map&lt;string,int&gt; M</code> ，那么 <code>M</code> 就是一个下标为 <code>string</code> 的数组，并且初始所有东西都是空，并且是 $0$ 。</p>
<p>当你以任何形式访问 <code>M[x]</code> 时，如果 <code>M[x]</code> 没有东西，那么会构造一个默认的 <code>M[x]</code> 。例如 <code>Val</code> 为 <code>int</code> 时就是 $0$ ，<code>Val</code> 为 <code>string</code> 时就是空串。</p>
<p><code>map</code> 里的元素同样可以通过迭代器访问。通过 <code>it = M.begin()</code> 访问 <code>map</code> 中的元素，并且 <code>*it</code> 会得到一个 <code>pair&lt;Key,Val&gt;</code> 。</p>
<p><code>map</code> 的操作和 <code>set</code> 基本一样。<code>lower_bound</code> 的时候是按照 <code>Key</code> 排序后查询的。在定义 <code>map</code> 时必须保证 <code>Key</code> 有顺序。</p>
<p>同理，也有 <code>unordered_map</code> ，是一个不基于 <code>Key</code> 的顺序，而是基于 Hash 的映射。</p>
<p>一般不使用 <code>multimap</code> 。</p>
<h3 id="例题-11-彩色糖"><a href="#例题-11-彩色糖" class="headerlink" title="例题 #11 彩色糖"></a>例题 #11 彩色糖</h3><p>枚举这个区间。可以将糖的颜色作为下标、糖的数量作为值放进 <code>map</code> 里。</p>
<p>然后每当遇到一个糖 $c$ 时就给 <code>M[c]</code> 加 $1$ ，每次把离开这个窗口的糖对应的 <code>M[c]</code> 减 $1$ 。</p>
<p>当 <code>M</code> 从 $0$ 到 $1$ 给颜色数加上 $1$ ，否则给颜色数减少 $1$ 。</p>
<h3 id="例题-12-Merge-Slimes"><a href="#例题-12-Merge-Slimes" class="headerlink" title="例题 #12 Merge Slimes"></a>例题 #12 Merge Slimes</h3><p>可以将 Slime 的大小作为下标，个数值放进 <code>map</code> 里。</p>
<p><code>map</code> 是按下标有序的，每次贪心地把最小的 slime 两两合并。合并完了后就删除对应的 <code>key</code> ，如果原来的个数是个奇数就会留下正好一只史莱姆，把得到的更大的史莱姆放到更大的下标的 <code>map</code> 中。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r="dwr2011.github.io"
        data-o="dwr2011"
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
